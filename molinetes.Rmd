---
title: "R Notebook"
output: html_notebook
---

# Series de tiempo: comparativa entre un modelo ARIMA y prophet

### Introducción

Importamos las librerías a utilizar

```{r, echo = TRUE, message=FALSE}

rm(list=ls())

require(dplyr)
require(ggplot2)
require(ggfortify)
require(tsibble)
require(lubridate)
require(prophet)
require(forecast)
```

### Análisis exploratorio

Importamos los datasets con los que se va a trabajar:

```{r}
df_abc <- read.csv("./datasets/202208_PAX15min-ABC.csv", sep=";")
df_deh <- read.csv("./datasets/202208_PAX15min-DEH.csv", sep=";")

df <- bind_rows(df_abc, df_deh)
rm(df_abc, df_deh)
print(colnames(df))

```

Agrupamos la información a nivel estación/horario y convertimos a formato fecha/hora:

```{r}
df_linea <- df %>% 
  group_by(FECHA,DESDE,HASTA,LINEA,ESTACION) %>% 
  summarize(pasajeros = sum(pax_TOTAL)) %>% 
  mutate(ts = dmy_hms(paste0(FECHA," " ,DESDE)))%>%
  ungroup() %>% 
  select(-c(FECHA, DESDE, HASTA))
```

Agrupamos por linea y observamos la cantidad de pasajeros para cada una de ellas:

```{r}
df_linea %>%
  filter(ts >= "2022-08-01 05:15:00" & ts <= "2022-08-07 23:15:00") %>%
  group_by(LINEA, ts) %>%
  summarise(pasajeros = sum(pasajeros)) %>%
  ggplot() +
  aes(x = ts, y = pasajeros, fill = LINEA, colour = LINEA, group = LINEA) +
  geom_line(size = 0.5) +
  scale_fill_manual(values = c(LineaA = "#5CD2FB", LineaB = "#FD2929", LineaC = "#1872D6", LineaD = "#39A029", LineaE = "#583FD2", LineaH = "#FFEC3B")) +
  scale_color_manual(values = c(LineaA = "#5CD2FB", LineaB = "#FD2929", LineaC = "#1872D6", LineaD = "#39A029", LineaE = "#583FD2", LineaH = "#FFEC3B")) +
  labs(x = "horario del día", y = "cantidad de pasajeros", title = "cantidad de pasajeros por linea") + 
  theme_linedraw() +
  theme(legend.position = "none") +
  facet_wrap(vars(LINEA)) + 
  scale_x_datetime(breaks= seq(min(df_linea$ts), max(df_linea$ts), by = "24 hour"), date_labels = "%a %H %M") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
library(plotly)
library(htmlwidgets)

<<<<<<< HEAD
setwd("D:\\OneDrive\\Personal\\Maestria Data Mining\\Cuatrimestre_2\\Enfoque Estadístico del Aprendizaje\\TP\\EEA-TPs\\TP2\\tp2-EEA-2022\\output")
#setwd("~/Documents/GitHub/tp2-EEA-2022/output")
=======
#setwd("D:\\OneDrive\\Personal\\Maestria Data Mining\\Cuatrimestre_2\\Enfoque Estadístico del Aprendizaje\\TP\\EEA-TPs\\TP2\\tp2-EEA-2022\\output")
setwd("~/Documents/GitHub/tp2-EEA-2022/output")
>>>>>>> 95184feae280ead229e5439890604d24f655cf31

dia <- c("2022-08-08","2022-08-09","2022-08-10","2022-08-11","2022-08-12","2022-08-13","2022-08-14")
dia_final <- c("2022-08-09","2022-08-10","2022-08-11","2022-08-12","2022-08-13","2022-08-14","2022-08-15")
nombre_dia <- c('Lunes','Martes','Miercoles','Jueves','Viernes','Sabado','Domingo')
i<- 1

lista_lineas <- c('LineaA','LineaB','LineaC','LineaD','LineaE','LineaH')
for (dia_inicial in dia){
  print(i)
  dia <- dia_inicial
  dia1 <- dia_final[i]
  nombre <- nombre_dia[i]
  print(dia)
  print(dia1)
  print(nombre)
    for (linea in lista_lineas){
    p <- df_linea %>%
    filter(ts > dia,ts<dia1,LINEA == linea) %>%
    ggplot() + geom_line(aes(ts, pasajeros,color=ESTACION)) + ggtitle(paste('Pasajeros para el dia',nombre,'en',linea,sep=" ")+
                                                                        scale_x_date(date_breaks = "1 hour", date_labels = "%H:%M") +
                                                                        scale_x_date(date_minor_breaks = "15 minutes"))
    #print(ggplotly(p))
    
    saveWidget(ggplotly(p), file = paste('Pasajeros para el dia',nombre,'en',linea,'.html',sep=" "));
    }
  i <- i+1
}


```

Para el análisis, nos vamos a quedar con la información de la estación palermo de la linea D y vamos a trabajar con los siguientes períodos:

Train: 1/08/2022 al 21/08/2022 Test: 22/08/2022 al 28/08/2022

```{r}
df_analisis <- df_linea %>%
  filter(ts > "2022-08-01" & ts < "2022-08-29" & ESTACION == "Palermo") %>%
  mutate(ts = floor_date(ts, unit = 'hour')) %>%
  group_by(ts) %>%
  summarise(y = sum(pasajeros)) %>%
  rename(ds = ts) %>%
  mutate(dia_semana = as.character(wday(ds, label=TRUE)),
<<<<<<< HEAD
         dia_numero = wday(ds),
         hora = as.character(hour(ds)),
         ndays = as.numeric(difftime(as.Date(ds),as.Date(ds)[1],units="days")),
         time_index = row_number()) %>% 
  as_tsibble(index = ds)
=======
         hora = as.character(hour(ds)),
         time_index = row_number())
>>>>>>> 95184feae280ead229e5439890604d24f655cf31

df_train <- df_analisis %>% 
  filter(ds < "2022-08-22")

df_test <- df_analisis %>% 
  filter(ds > "2022-08-22")

```

Observo la serie:

```{r}
df_analisis %>%
  ggplot(aes(x = ds, y=y)) +
  geom_line(colour = "#39A029") +
  labs(x = "horario del día", y = "cantidad de pasajeros", title = "cantidad de pasajeros de la estación Palermo") + 
  theme_linedraw() +
  theme(legend.position = "none") + 
  scale_x_datetime(breaks= seq(min(df_analisis$ds), max(df_analisis$ds), by = "12 hour"), date_labels = "%a %H %M") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5)) + 
  geom_vline(aes(xintercept=min(df_test$ds), color='red')) +
  geom_text(aes(x=min(df_test$ds) , label="TRAIN     TEST", y=1600), colour="red", angle=0)



```

<<<<<<< HEAD
En primer lugar, se va a armar una regresión lineal con la tendencia y las variables estacionales. Luego, utilizará ARIMA para intentar captar cierto componente autoregresivo en la serie.

### ARIMA


```{r}
#Defino serie temporal con las 18 horas laborales separando por dia
ts_train <- ts(df_train[-1],freq=18)

#Queda la serie univariada
ts_train <- ts_train [,'y']
```

#### Autocorrelación

```{r}
ggAcf(ts_train)
```
Se observa que la serie presenta coeficientes de autocorrelación se presentan por fuera de la banda azul, que indica que las mismas son significativamente diferentes de 0.

### ¿Es la serie estacionaria?
Se propone realizar el test de Ljung-Box para validar la información del gráfico. 


```{r}
Box.test(diff(tser),lag=10,type='Ljung-Box')

```
Se desprende que la serie no es estacionaria.

## Estacionalidad y tendencia


```{r}
#Grafico considerando una estacionalidad horaria
ts_train %>% 
  stl(s.window = 18) %>% 
  autoplot(ts.colour='blue')

#Dando el parámetro automatico se obtiene

ts_train %>% 
  mstl() %>% 
  autoplot()
```

Para saber si se debe diferenciar la serie se puede utilizar un test "Unit Root". Se emplea a continuación el test KPSS(Kwiatkowski-Phillips-Schmidt-Shin), cuya hipótesis nula es que los datos son estacionarios. p-valores inferiores a 0,05 sugieren que se debe diferenciar la serie


```{r}
library(urca)
ts_train %>% ur.kpss() %>%  summary()
```
Se rechaza hipótesis nula. Se procede a diferenciar la serie

```{r}
ts_train %>% diff() %>% ur.kpss() %>%  summary()
```
Con una diferenciación basta para hacer que la serie se comporte de forma estacionaria


#### Implementación modelo ARIMA automático

Se implementa la función auto.arima, que realiza los siguientes pasos para obtener el modelo ARIMA(p,d,q):

1. Búsqueda del número de diferencias con test KPSS como se realizó anteriormente sobre la serie.
2. Valores de "p" y "q" se obtienen minimizando el AIC luego de diferenciar la serie. No se prueban todos los modelos si no que se adoptan 4 modelos iniciales para realizar la búsqueda de los parámetros

Sin embargo, este procedimiento no verifica tener ruido blanco en los residuos del modelo, por lo se procede a hacer un ARIMA manual


```{r}
library(forecast)

auto_arima <- auto.arima(ts_train)
summary(auto_arima)
```

```{r}
valores_prediccion <- forecast(auto_arima,126)
autoplot(valores_prediccion)
```

#### ARMA manual

```{r}
ts_train %>% stl(s.window='periodic') %>% seasadj() -> ts_train_adj
autoplot(ts_train_adj)
```

Diferenciando la serie y observando el ACF y PACF se obtiene:

```{r}
ts_train_adj %>% diff() %>% ggtsdisplay(main='')
#Verifico que sea estacional

ts_train_adj%>% diff() %>% ur.kpss() %>%  summary()


```
Para determinar los parámetros a utilizar, el parámetro "p" se obtiene del gráfico de PACF. Se prueba seteando el valor a 9, que se corresponde con las veces que significativamente el coeficiente toma valores por fuera del umbral para el primer ciclo

```{r}
(fit <- Arima(ts_train_adj, order=c(12,1,0)))
checkresiduals(fit)

```
```{r}
autoplot(forecast(fit))
```

=======
### ARIMA

En primer lugar, se va a armar una regresión lineal con la tendencia y las variables estacionales. Luego, utilizará ARIMA para intentar captar cierto componente autoregresivo en la serie.
>>>>>>> 95184feae280ead229e5439890604d24f655cf31

```{r}
df_train %>%
  select(ds, y) %>% as_tsibble(index = ds) %>% as.ts() %>% mstl(s.window = c(7,  7*24)) %>%
  autoplot() (s.window='periodic') %>% seasadj() -> eeadj

<<<<<<< HEAD
=======

>>>>>>> 95184feae280ead229e5439890604d24f655cf31
```

OTRO ENFOQUE:

```{r}
reg = lm(log(y) ~ dia_semana + hora + time_index, data = df_train)
summary(reg)
```

```{r}
plot(reg)
```



realizo algunas modificaciones para poder trabajar con la serie:


```{r}

```

se podría sumar algún gráfico en el que se vea la estacionalidad horaria:

```{r}

```

grafico autocorrelacion

```{r}
df_lineaD %>%
  as.ts() %>%
  Acf() %>%
  autoplot()
```

```{r}
df_lineaD %>%
  as.ts() %>%
  gg_tsdisplay(difference(y, 1),
               plot_type='partial', lag=36)
```

### Prophet

```{r}
# Feriados
feriados = data.frame(
  holiday= 'feriados',
  ds= ymd(c('2022-08-15')),
  lower_window= 0,
  upper_window= 0)

```

```{r}
# Llamamos al modelo con el dataset de eventos
prophet_full=prophet(changepoint.prior.scale=0.01, holidays = feriados)

# Agregamos la estacionalidad mensual
#prophet_full=add_seasonality(prophet_full, name='monthly', period=30.5, fourier.order = 4)

# Le pasamos el dataset
prophet_full = fit.prophet(m = prophet_full, df_train) 
```

```{r}
prophet_plot_components(prophet_full, fcst=predict(prophet_full, df_train))
```

```{r}
#future <- make_future_dataframe(m, periods = 365)
forecast <- predict(prophet_full, df_test)   ## chequear si esto está ok.

resultado = cbind(df_test, forecast$yhat)
colnames(resultado) <- c("dia", "pasajeros", "prediccion")

require(Metrics)
rmse(resultado$pasajeros, resultado$prediccion)
```

```{r}
plot(resultado$dia,                              # Draw first time series
     resultado$pasajeros,
     type = "l",
     col = 2,
     #ylim = c(- 15, 40),
     xlab = "Year",
     ylab = "Values")
lines(resultado$dia,                             # Draw second time series
      resultado$prediccion,
      type = "l",
      col = 3)
```

### Bibliografía
<<<<<<< HEAD
=======

>>>>>>> 95184feae280ead229e5439890604d24f655cf31
