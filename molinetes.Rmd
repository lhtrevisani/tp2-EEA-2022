---
title: "R Notebook"
output: html_notebook
---

# Series de tiempo: comparativa entre un modelo ARIMA y prophet

En el siguiente trabajo se abordará la modelización y la predicción de la serie temporal de pasajeros del subte de Buenos Aires utilizando ARIMA y prophet. 

### Introducción

En primer lugar, importamos las librerías a utilizar:

```{r, echo = TRUE, message=FALSE}

rm(list=ls())

require(dplyr)
require(ggplot2)
require(ggfortify)
require(tsibble)
require(lubridate)
require(prophet)
require(forecast)
require(broom)
require(tseries)
require(fable)
```

### Análisis exploratorio

Importamos los datasets con los que se va a trabajar:

```{r}
df_abc <- read.csv("./datasets/202208_PAX15min-ABC.csv", sep=";")
df_deh <- read.csv("./datasets/202208_PAX15min-DEH.csv", sep=";")

df <- bind_rows(df_abc, df_deh)
rm(df_abc, df_deh)
print(colnames(df))

```

Agrupamos la información a nivel estación/horario y convertimos a formato fecha/hora:

```{r}
df_linea <- df %>% 
  group_by(FECHA,DESDE,HASTA,LINEA,ESTACION) %>% 
  summarize(pasajeros = sum(pax_TOTAL)) %>% 
  mutate(ts = dmy_hms(paste0(FECHA," " ,DESDE)))%>%
  ungroup() %>% 
  select(-c(FECHA, DESDE, HASTA))
```

Agrupamos por linea y observamos la cantidad de pasajeros para cada una de ellas:

```{r}
df_linea %>%
  filter(ts >= "2022-08-01 05:15:00" & ts <= "2022-08-07 23:15:00") %>%
  group_by(LINEA, ts) %>%
  summarise(pasajeros = sum(pasajeros)) %>%
  ggplot() +
  aes(x = ts, y = pasajeros, fill = LINEA, colour = LINEA, group = LINEA) +
  geom_line(size = 0.5) +
  scale_fill_manual(values = c(LineaA = "#5CD2FB", LineaB = "#FD2929", LineaC = "#1872D6", LineaD = "#39A029", LineaE = "#583FD2", LineaH = "#FFEC3B")) +
  scale_color_manual(values = c(LineaA = "#5CD2FB", LineaB = "#FD2929", LineaC = "#1872D6", LineaD = "#39A029", LineaE = "#583FD2", LineaH = "#FFEC3B")) +
  labs(x = "horario del día", y = "cantidad de pasajeros", title = "cantidad de pasajeros por linea") + 
  theme_linedraw() +
  theme(legend.position = "none") +
  facet_wrap(vars(LINEA)) + 
  scale_x_datetime(breaks= seq(min(df_linea$ts), max(df_linea$ts), by = "24 hour"), date_labels = "%a %H %M") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

A continuación, analizamos la cantidad de pasajeros para cada estación de cada una de las lineas de subte:

```{r, include = FALSE, warning=FALSE, message=FALSE}
library(plotly)
library(htmlwidgets)

#setwd("D:\\OneDrive\\Personal\\Maestria Data Mining\\Cuatrimestre_2\\Enfoque Estadístico del Aprendizaje\\TP\\EEA-TPs\\TP2\\tp2-EEA-2022\\output")
setwd("~/Documents/GitHub/tp2-EEA-2022/output")

dia <- c("2022-08-08","2022-08-09","2022-08-10","2022-08-11","2022-08-12","2022-08-13","2022-08-14")
dia_final <- c("2022-08-09","2022-08-10","2022-08-11","2022-08-12","2022-08-13","2022-08-14","2022-08-15")
nombre_dia <- c('Lunes','Martes','Miercoles','Jueves','Viernes','Sabado','Domingo')
i<- 1

lista_lineas <- c('LineaA','LineaB','LineaC','LineaD','LineaE','LineaH')
for (dia_inicial in dia){
  print(i)
  dia <- dia_inicial
  dia1 <- dia_final[i]
  nombre <- nombre_dia[i]
  print(dia)
  print(dia1)
  print(nombre)
    for (linea in lista_lineas){
    p <- df_linea %>%
    filter(ts > dia,ts<dia1,LINEA == linea) %>%
    ggplot() + geom_line(aes(ts, pasajeros,color=ESTACION)) + ggtitle(paste('Pasajeros para el dia',nombre,'en',linea,sep=" ")+
                                                                        scale_x_date(date_breaks = "1 hour", date_labels = "%H:%M") +
                                                                        scale_x_date(date_minor_breaks = "15 minutes"))
    #print(ggplotly(p))
    
    saveWidget(ggplotly(p), file = paste('Pasajeros para el dia',nombre,'en',linea,'.html',sep=" "));
    }
  i <- i+1
}


```

Para el análisis, nos vamos a quedar con la información de la estación palermo de la linea D y vamos a trabajar con los siguientes períodos:

Train: 1/08/2022 al 21/08/2022 Test: 22/08/2022 al 28/08/2022

```{r}

feriados = as.Date(c("2022-08-15"))

df_analisis <- df_linea %>%
  filter(ts > "2022-08-01" & ts < "2022-08-29" & ESTACION == "Palermo") %>%
  mutate(ts = floor_date(ts, unit = 'hour')) %>%
  group_by(ts) %>%
  summarise(y = sum(pasajeros)) %>%
  rename(ds = ts) %>%
  mutate(dia_semana = as.character(wday(ds, label=TRUE)),
         hora = as.character(hour(ds)),
         time_index = row_number(),
         log_y = log(y),
         feriado = if_else(as.Date(floor_date(ds, unit = 'day')) %in% feriados, TRUE, FALSE))

df_train <- df_analisis %>% 
  filter(ds < "2022-08-22")

df_test <- df_analisis %>% 
  filter(ds > "2022-08-22")

```

Observo la serie:

```{r}
df_analisis %>%
  ggplot(aes(x = ds, y=y)) +
  geom_line(colour = "#39A029") +
  labs(x = "horario del día", y = "cantidad de pasajeros", title = "cantidad de pasajeros de la estación Palermo") + 
  theme_linedraw() +
  theme(legend.position = "none") + 
  scale_x_datetime(breaks= seq(min(df_analisis$ds), max(df_analisis$ds), by = "12 hour"), date_labels = "%a %H %M") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5)) + 
  geom_vline(aes(xintercept=min(df_test$ds), color='red')) +
  geom_text(aes(x=min(df_test$ds) , label="TRAIN     TEST", y=1600), colour="red", angle=0)

```

### ARIMA



```{r}
df_train %>%
  select(ds, y) %>% as_tsibble(index = ds) %>% as.ts() %>% mstl(s.window = c(7,  7*24)) %>%
  autoplot() (s.window='periodic') %>% seasadj() -> eeadj


```

OTRO ENFOQUE:

En primer lugar, se va a armar una regresión lineal con la tendencia y las variables estacionales. Luego, utilizará ARIMA para intentar captar cierto componente autoregresivo en la serie.

```{r}
reg = lm(log_y ~ dia_semana + hora + feriado + time_index, data = df_train)
summary(reg)
```

Realizamos la predicción para train y para test:

```{r}
df_train$y_hat_log = predict(reg)
df_test$y_hat_log = predict(reg, newdata = df_test)
```

Calculo la exponencial de las predicciones para llevarlo a la escala real de la serie:

```{r}
df_train$y_hat = exp(df_train$y_hat_log)
df_test$y_hat = exp(df_test$y_hat_log)
```

Ploteo los valores de test y las predicciones de este primer modelo:

```{r}

plot(df_test$ds,                              # Draw first time series
     df_test$y,
     type = "l",
     col = 2,
     #ylim = c(- 15, 40),
     xlab = "Year",
     ylab = "Values")
lines(df_test$ds,                             # Draw second time series
      df_test$y_hat,
      type = "l",
      col = 3)
```

Calculamos los residuos:

```{r}
df_train$residuos = reg$residuals
plot(df_train$residuos)
```

Probamos la estacionariedad de la serie con el test de dickey-fuller:

```{r}
adf.test(df_train$residuos)
```

Se observa que la serie es estacionaria. No sería necesario transformarla o diferenciarla.

Observamos la serie y los gráficos de la función de autocorrelación y la de autocorrelación parcial para ver qué valores de p y q debería tomar el modelo ARMA:

```{r}
library(feasts)

gg_tsdisplay(df_train %>% as_tsibble(index = ds) %>% fill_gaps() %>% select(residuos), plot_type='partial')

```

Utilizando la librería fable, probamos varios modelos ARIMA (incluso algunos que nos propone una exploración más exhaustiva) y nos quedamos con aquel que tenga el menor AIC:

```{r}
require(fable)

modelos = df_train %>% as_tsibble(index = ds) %>% fill_gaps() %>%
  model(arima200 = ARIMA(residuos ~ pdq(2,0,0)),
        arima001 = ARIMA(residuos ~ pdq(0,0,1)),
        arima201 = ARIMA(residuos ~ pdq(2,0,1)),
        stepwise = ARIMA(residuos),
        search = ARIMA(residuos, stepwise=FALSE))

glance(modelos) %>% arrange(AICc) %>% select(.model:BIC)

```

Analizo los residuos del arima:

```{r}

modelos %>%
  select(arima200) %>% 
  gg_tsresiduals()
```


Realizo las predicciones sobre test:

```{r}

pred_test = modelos %>%
  select(search) %>% fitted()

modelos %>%
  select(search) %>% forecast(h = "1 week")
```

sumo predicción del modelo anterior + arima tanto para train como para test.

```{r}

df_train$arima_pred = modelos %>% select(search) %>% fitted()
df_test$arima_pred

```

Transformo aplicando la exponencial:

```{r}

```

Ploteo predicción vs valores reales:

```{r}

```

Calculo RMSE:

```{r}

```



### Prophet

```{r}
# Feriados
feriados = data.frame(
  holiday= 'feriados',
  ds= ymd(c('2022-08-15')),
  lower_window= 0,
  upper_window= 0)

```

```{r}
# Llamamos al modelo con el dataset de eventos
prophet_full=prophet(changepoint.prior.scale=0.01, holidays = feriados)

# Agregamos la estacionalidad mensual
#prophet_full=add_seasonality(prophet_full, name='monthly', period=30.5, fourier.order = 4)

# Le pasamos el dataset
prophet_full = fit.prophet(m = prophet_full, df_train) 
```

```{r}
prophet_plot_components(prophet_full, fcst=predict(prophet_full, df_train))
```

```{r}
#future <- make_future_dataframe(m, periods = 365)
forecast <- predict(prophet_full, df_test)   ## chequear si esto está ok.

resultado = cbind(df_test, forecast$yhat)
colnames(resultado) <- c("dia", "pasajeros", "prediccion")

require(Metrics)
rmse(resultado$pasajeros, resultado$prediccion)
```

```{r}
plot(resultado$dia,                              # Draw first time series
     resultado$pasajeros,
     type = "l",
     col = 2,
     #ylim = c(- 15, 40),
     xlab = "Year",
     ylab = "Values")
lines(resultado$dia,                             # Draw second time series
      resultado$prediccion,
      type = "l",
      col = 3)
```

### Bibliografía

